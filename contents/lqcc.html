<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Roger Luo" />
  <title>Julia简介</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="../css/reveal.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <link rel="stylesheet" href="../css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="../lib/css/zenburn.css">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->

    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$', '$$'], ["\\[", "\\]"] ],
          processEscapes: true
        },
        TeX: {
          equationNumbers: {
            autoNumber: 'AMS'
          }
        },
        "HTML-CSS": {
          imageFont: null
        }
      });
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/2.1-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Julia简介</h1>
<h3 class="author">Roger Luo</h3>
<h3 class="date"></h3>
</section>


<section id="intro" class="slide level1">
<h1>Intro</h1>
<p>Julia 是一款具有高性能的动态语言,速度快,很好的结合现在流型的一些新的计算机技术,如云计算,分布式计算等等.在机器学习方面已经开始崭露头角.</p>
</section>
<section id="特性" class="slide level1">
<h1>特性</h1>
<ul>
<li>支持多重派发</li>
<li>动态类型系统</li>
<li>近乎于静态编译语言的速度</li>
<li>内建的包管理器</li>
<li>类似于Lisp的宏命令和其它metaprogramming功能</li>
<li>可以调用Python</li>
<li>无其额外开销地调用C</li>
</ul>
</section>
<section id="section" class="slide level1">
<h1></h1>
<ul>
<li>强大的类shell的命令管理</li>
<li>为分布式和并行计算设计</li>
<li>支持协程</li>
<li>用户定义的类型和内建类型一样快</li>
<li>简洁可扩展的类型转换和类型提升</li>
<li>对unicode的有效支持</li>
<li>MIT license</li>
</ul>
</section>
<section id="benchmarks" class="slide level1">
<h1>Benchmarks</h1>
</section>
<section id="section-1" class="slide level1">
<h1></h1>
<table>
<thead>
<tr class="header">
<th></th>
<th>Fortran</th>
<th>Julia</th>
<th>Python</th>
<th>R</th>
<th>Matlab</th>
<th>Octave</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>fib</td>
<td>0.70</td>
<td>2.11</td>
<td>77.76</td>
<td>533.52</td>
<td>26.89</td>
<td>9324.35</td>
</tr>
<tr class="even">
<td>parse_int</td>
<td>5.05</td>
<td>1.45</td>
<td>17.02</td>
<td>45.73</td>
<td>802.52</td>
<td>9581.44</td>
</tr>
<tr class="odd">
<td>quicksort</td>
<td>1.31</td>
<td>1.15</td>
<td>32.89</td>
<td>264.54</td>
<td>4.92</td>
<td>1866.01</td>
</tr>
<tr class="even">
<td>mandel</td>
<td>0.81</td>
<td>0.79</td>
<td>15.32</td>
<td>53.16</td>
<td>7.58</td>
<td>451.81</td>
</tr>
<tr class="odd">
<td>pi_sum</td>
<td>1.00</td>
<td>1.00</td>
<td>21.99</td>
<td>9.56</td>
<td>1.00</td>
<td>299.31</td>
</tr>
<tr class="even">
<td>rand_mat_stat</td>
<td>1.45</td>
<td>1.66</td>
<td>17.93</td>
<td>14.56</td>
<td>14.52</td>
<td>30.93</td>
</tr>
<tr class="odd">
<td>rand_mat_mul</td>
<td>3.48</td>
<td>1.02</td>
<td>1.14</td>
<td>1.57</td>
<td>1.12</td>
<td>1.12</td>
</tr>
</tbody>
</table>
</section>
<section id="section-2" class="slide level1">
<h1></h1>
<table>
<thead>
<tr class="header">
<th></th>
<th>Mathematica</th>
<th>JavaScript</th>
<th>Go</th>
<th>LuaJIT</th>
<th>Java</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>fib</td>
<td>118.53</td>
<td>3.36</td>
<td>1.86</td>
<td>1.71</td>
<td>1.21</td>
</tr>
<tr class="even">
<td>parse_int</td>
<td>15.02</td>
<td>6.06</td>
<td>1.20</td>
<td>5.77</td>
<td>3.35</td>
</tr>
<tr class="odd">
<td>quicksort</td>
<td>43.23</td>
<td>2.70</td>
<td>1.29</td>
<td>2.03</td>
<td>2.60</td>
</tr>
<tr class="even">
<td>mandel</td>
<td>5.13</td>
<td>0.66</td>
<td>1.11</td>
<td>0.67</td>
<td>1.35</td>
</tr>
<tr class="odd">
<td>pi_sum</td>
<td>1.69</td>
<td>1.01</td>
<td>1.00</td>
<td>1.00</td>
<td>1.00</td>
</tr>
<tr class="even">
<td>rand_mat_stat</td>
<td>5.95</td>
<td>2.30</td>
<td>2.96</td>
<td>3.27</td>
<td>3.92</td>
</tr>
<tr class="odd">
<td>rand_mat_mul</td>
<td>1.30</td>
<td>15.07</td>
<td>1.42</td>
<td>1.16</td>
<td>2.36</td>
</tr>
</tbody>
</table>
</section>
<section id="hello-world" class="slide level1">
<h1>Hello World!</h1>
<p>从最基本的开始</p>
<p>Julia可以直接在命令行中运行</p>
<pre class="bash"><code>julia -e &#39;print(&quot;hello world!\n&quot;)&#39;</code></pre>
<p>或者打开Julia的shell,输入</p>
<pre class="bash"><code>julia&gt; print(&quot;hello world!\n&quot;)</code></pre>
<p>或者可以在一个脚本文件<code>hello.jl</code>中写入</p>
<pre class="julia"><code>print(&quot;hello world!\n&quot;)</code></pre>
</section>
<section id="变量-variables" class="slide level1">
<h1>变量 Variables</h1>
<p>Julia的变量不需要特别声明,变量类型会由值自动确定</p>
<pre class="julia"><code># 将10赋值给变量x
julia&gt; x=10
10
# 对变量x进行运算
julia&gt; x+1
11
# 重新给x赋值
julia&gt; x=1+1
# 也可以给x赋其它类型的值
julia&gt; x=&quot;hello world!&quot;
hello world!</code></pre>
</section>
<section id="julia的变量名称支持unicode比如" class="slide level1">
<h1>Julia的变量名称支持unicode比如</h1>
<pre class="julia"><code>julia&gt; δ = 0.00001
1.0e-5
julia&gt; 你好 = &quot;hello&quot;
hello</code></pre>
</section>
<section id="section-3" class="slide level1">
<h1></h1>
<p>支持以LaTex语法输入特殊字符,在Julia的命令行,Jupyter,有juliacompletions插件的sublime编辑器中都可以用类似于的LaTex命令+Tab输入特殊字符,比如<code>δ</code> 可以通过输入<code>\delta</code>-Tab来得到</p>
</section>
<section id="section-4" class="slide level1">
<h1></h1>
<p>Julia有一些自带的常量,这些常量是允许重载的.比如</p>
<pre class="julia"><code>julia&gt; pi
π = 3.1415926535897...
julia&gt; pi = 3
WARNING: imported binding for pi overwritten in module Main
3
julia&gt; π
3</code></pre>
</section>
<section id="整数和浮点数" class="slide level1">
<h1>整数和浮点数</h1>
<ul>
<li>整数从8位整数支持到128位整数(Signed/Unsigned)</li>
<li>浮点数从16位浮点数支持到64位浮点数,如果有高精度的计算需求还可以使用内建的高精度浮点数<code>BigFloat</code>(256位)</li>
</ul>
</section>
<section id="整数" class="slide level1">
<h1>整数</h1>
<p>整数默认跟随系统位数,比如在32位系统上整数类型为<code>Int32</code>,在64位系统上整数类型为<code>Int64</code></p>
</section>
<section id="浮点数" class="slide level1">
<h1>浮点数</h1>
<p>浮点数的-0和-0在二进制表示下不一致(有符号位),但不影响大小比较</p>
<pre class="julia"><code>julia&gt; 0.0 == -0.0
true</code></pre>
</section>
<section id="浮点精度" class="slide level1">
<h1>浮点精度</h1>
<p>浮点精度可以用函数<code>eps</code>直接求出,比如<code>eps(Float32)</code></p>
</section>
<section id="数学算符和基本函数" class="slide level1">
<h1>数学算符和基本函数</h1>
<table>
<thead>
<tr class="header">
<th>表达式</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>+x</td>
<td>unary plus</td>
<td>the identity operation</td>
</tr>
<tr class="even">
<td>-x</td>
<td>unary minus</td>
<td>maps values to their additive inverses</td>
</tr>
<tr class="odd">
<td>x+y</td>
<td>binary plus</td>
<td>performs addition</td>
</tr>
<tr class="even">
<td>x-y</td>
<td>binary minus</td>
<td>performs subtraction</td>
</tr>
</tbody>
</table>
</section>
<section id="section-5" class="slide level1">
<h1></h1>
<table>
<thead>
<tr class="header">
<th>表达式</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x*y</td>
<td>times</td>
<td>performs multiplication</td>
</tr>
<tr class="even">
<td>x/y</td>
<td>divide</td>
<td>performs division</td>
</tr>
<tr class="odd">
<td>x\y</td>
<td>inverse divide</td>
<td>equivalent to <code>y/x</code></td>
</tr>
<tr class="even">
<td>x^y</td>
<td>power</td>
<td>raises <code>x</code> to the <code>y</code>th power</td>
</tr>
<tr class="odd">
<td>x%y</td>
<td>remainder</td>
<td>equivalent to <code>rem(x,y)</code></td>
</tr>
</tbody>
</table>
</section>
<section id="数值比较" class="slide level1">
<h1>数值比较</h1>
<table>
<thead>
<tr class="header">
<th>表达式</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>==</code></td>
<td>equality</td>
</tr>
<tr class="even">
<td><code>!=</code> <code>≠</code></td>
<td>inequality</td>
</tr>
<tr class="odd">
<td><code>&lt;</code></td>
<td>less than</td>
</tr>
<tr class="even">
<td><code>&lt;=</code> <code>≤</code></td>
<td>less than or equal to</td>
</tr>
<tr class="odd">
<td><code>&gt;</code></td>
<td>greater than</td>
</tr>
<tr class="even">
<td><code>&gt;=</code> <code>≥</code></td>
<td>greater than or equal to</td>
</tr>
</tbody>
</table>
</section>
<section id="tips" class="slide level1">
<h1>Tips</h1>
<p>可以使用类似于<code>1&lt;x&lt;2</code> 这样更自然的表达</p>
</section>
<section id="复数和分数" class="slide level1">
<h1>复数和分数</h1>
<p>复数和分数是两个内建的类型,已经为他们写好了几乎所有的函数和运算符</p>
</section>
<section id="复数" class="slide level1">
<h1>复数</h1>
<p>虚数单位是<code>im</code></p>
<pre class="julia"><code>julia&gt; 1+2im
1 + 2im</code></pre>
</section>
<section id="section-6" class="slide level1">
<h1></h1>
<pre class="julia"><code>julia&gt; real(1+2im)
1
julia&gt; imag(1+2im)
2
julia&gt; conj(1+2im)
1 - 2im
julia&gt; abs(1+2im)
2.23606797749979
julia&gt; angle(1 + 2im)
1.1071487177940904</code></pre>
</section>
<section id="构造函数" class="slide level1">
<h1>构造函数</h1>
<p>虚数的构造函数是<code>complex</code></p>
<pre class="julia"><code>julia&gt; complex(1,2)
1 + 2im</code></pre>
</section>
<section id="分数" class="slide level1">
<h1>分数</h1>
<p>分数线用<code>//</code>表示,比如<span class="math inline">$\frac{2}{3}$</span>在julia中写作<code>2//3</code>,所有的分数会自动化简为真分数,比如</p>
<pre class="julia"><code>julia&gt; 6//9
2//3</code></pre>
</section>
<section id="字符串" class="slide level1">
<h1>字符串</h1>
<p>字符串存在一个数组中</p>
<pre class="julia"><code>julia&gt; str = &quot;Hello, world.\n&quot;
&quot;Hello, world.\n&quot;

julia&gt; str[1]
&#39;H&#39;

julia&gt; str[6]
&#39;,&#39;

julia&gt; str[end]
&#39;\n&#39;</code></pre>
</section>
<section id="函数" class="slide level1">
<h1>函数</h1>
<p>函数声明如下</p>
<pre class="julia"><code>function f(x,y)
    return x+y
end</code></pre>
<p><code>return</code> 关键会返回后面跟随的值,并退出函数</p>
<p>julia支持多返回值,比如</p>
<pre class="julia"><code>function foo(x,y)
    return x,y
end</code></pre>
</section>
<section id="section-7" class="slide level1">
<h1></h1>
<p>将以tuple类型返回多个值</p>
<pre class="julia"><code>julia&gt; foo(1,2)
(1,2)</code></pre>
</section>
<section id="section-8" class="slide level1">
<h1></h1>
<p>函数也可以用这样简单的方式声明</p>
<pre class="julia"><code>f(x) = sqrt(x)+1

julia&gt; f(1)
2</code></pre>
</section>
<section id="运算符也是函数" class="slide level1">
<h1>运算符也是函数</h1>
</section>
<section id="匿名函数" class="slide level1">
<h1>匿名函数</h1>
<pre class="julia"><code>julia&gt; x-&gt;x^2+x
(anonymous function)

julia&gt; function (x)
            x^2 + 2x - 1
       end
(anonymous function)</code></pre>
</section>
<section id="匿名函数很有用举个例子" class="slide level1">
<h1>匿名函数很有用,举个例子</h1>
<pre class="julia"><code># 找出值为1的元素在数组中的位置
julia&gt; find(x-&gt;x==1,[1,2,3,1])
2-element Array{Int64,1}:
 1
 4</code></pre>
</section>
<section id="section-9" class="slide level1">
<h1></h1>
<p>函数的变量不需要专门进行类型约束,但在需要的时候(比如需要提高程序性能),可以用<code>::</code>来强制变量类型</p>
<pre class="julia"><code>julia&gt; function foo(a::Int64)
       return a
       end
foo (generic function with 2 methods)

julia&gt; foo(1.1)
ERROR: MethodError: `foo` has no method matching foo(::Float64)</code></pre>
</section>
<section id="函数变量中可以出现可选变量" class="slide level1">
<h1>函数变量中可以出现可选变量</h1>
<pre class="julia"><code>function foo(a = 1)
    return a
end

julia&gt; foo()
1
julia&gt; foo(2)
2 </code></pre>
</section>
<section id="可以出现关键词变量" class="slide level1">
<h1>可以出现关键词变量</h1>
<pre class="julia"><code>function foo(x,y;t=1)
    print(&quot;x = $(x),y = $(y),t=$(t)&quot;)
end

julia&gt; foo(1,2)
x = 1,y = 2,t=1
julia&gt; foo(1,2,t=2)
x = 1,y = 2,t=2
julia&gt; foo(1,2,2)
ERROR: MethodError: `foo` has no method matching foo(::Int64, ::Int64, ::Int64)</code></pre>
</section>
<section id="section-10" class="slide level1">
<h1></h1>
<p>注意函数中的变量都是call by reference,但函数中不允许改变除了Array类型以外的外部变量的值.如果所创建的函数对外部值进行了修改,则在<strong>Julia的命名规范</strong>中建议以<code>xxx!</code>的形式进行命名,比如</p>
<pre class="julia"><code>function foo!(x::AbstractArray)
    x[1] = 2
end</code></pre>
</section>
<section id="if-else语句" class="slide level1">
<h1>if else语句</h1>
<pre class="julia"><code>if x &lt; y
  println(&quot;x is less than y&quot;)
elseif x &gt; y
  println(&quot;x is greater than y&quot;)
else
  println(&quot;x is equal to y&quot;)
end</code></pre>
</section>
<section id="abc" class="slide level1">
<h1>a?b:c</h1>
<p>如果a为<code>true</code> 那么执行<code>b</code>,如果a为<code>false</code> 执行<code>c</code></p>
</section>
<section id="loops" class="slide level1">
<h1>Loops</h1>
</section>
<section id="while" class="slide level1">
<h1>while</h1>
<pre class="julia"><code>julia&gt; i = 1;

julia&gt; while i &lt;= 5
         println(i)
         i += 1
       end
1
2
3
4
5</code></pre>
</section>
<section id="for" class="slide level1">
<h1>for</h1>
<pre class="julia"><code>julia&gt; for i = 1:5
         println(i)
       end
1
2
3
4
5</code></pre>
</section>
<section id="section-11" class="slide level1">
<h1></h1>
<pre class="julia"><code>julia&gt; for i in [1,4,0]
         println(i)
       end
1
4
0

julia&gt; for s in [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]
         println(s)
       end
foo
bar
baz</code></pre>
</section>
<section id="变量" class="slide level1">
<h1>变量</h1>
<p>变量可以用<code>type</code>来创建,类似与c++和python的<code>class</code>,但由于Julia的面向对象采用的是多重派发,并不支持在类型内部创建属于本类型的函数(method),但可以穿件构造函数</p>
<pre class="julia"><code>type foo
    a::Int64
    b
    foo(x,y) = new(x,y)
end</code></pre>
<p><code>new</code>函数按照顺序给<code>foo</code>中的两个变量赋值</p>
</section>
<section id="使用packagemodules" class="slide level1">
<h1>使用package/modules</h1>
<p>module关键词提供了命名空间,一般类库或者框架都会用module进行封装.使用某个库的方法是(以IJulia为例)</p>
<pre class="julia"><code>using IJulia
notebook()</code></pre>
</section>
<section id="section-12" class="slide level1">
<h1></h1>
<p>这样就将在<code>IJulia</code> 这个module中<code>export</code> 出的函数(包括构造函数)直接放在了当前的名字空间里.</p>
<p>而如果采用 <code>import</code> 则需要先指出名字空间</p>
<pre class="julia"><code>import IJulia
IJulia.notebook()</code></pre>
</section>
<section id="安装package" class="slide level1">
<h1>安装package</h1>
<p>Julia大部分的开源库都会托管在github上,Julia内置了git,可以自动从github等网站上下载库文件.</p>
<p>若某个库的名字叫<code>xxx</code>使用<code>Pkg.add(&quot;xxx&quot;)</code>就可以自动安装这个库</p>
</section>
<section id="矩阵" class="slide level1">
<h1>矩阵</h1>
<p>Julia的矩阵是直接用数组进行声明的,并且是列主序的</p>
</section>
<section id="section-13" class="slide level1">
<h1></h1>
<p>若要声明一个矩阵 <br /><span class="math display">$$
\begin{pmatrix}
1 &amp; 0\\
2 &amp; 1
\end{pmatrix}
$$</span><br /></p>
<pre class="julia"><code>julia&gt; [1 0;2 1]
2x2 Array{Int64,2}:
 1  0
 2  1</code></pre>
</section>
<section id="section-14" class="slide level1">
<h1></h1>
<p>矩阵计算会自动调用在安装时配置的BLAS库,默认的BLAS是openBLAS.在小型服务器和个人电脑上表现可能会比MKL好.</p>
</section>
<section id="稀疏矩阵" class="slide level1">
<h1>稀疏矩阵</h1>
<p>使用<code>sparse</code>函数将dense matrix转化为稀疏矩阵存储</p>
<pre class="julia"><code>julia&gt; sparse([0 1;1 0])
2x2 sparse matrix with 2 Int64 entries:
    [2, 1]  =  1
    [1, 2]  =  1</code></pre>
</section>
<section id="juliaquantum" class="slide level1">
<h1>JuliaQuantum</h1>
<p>JuliaQuantum 是一个使用Julia语言的开源组织,NumFocus为其保护伞组织(为其提供主要支持),致力于用Julia语言实现高性能的量子力学相关计算框架,类库.现在已经有了QuDynamics.jl,QuDirac.jl,QuBase.jl三个正在开发的库,其中QuDynamics.jl是15年参加GSoC的项目.</p>
<p>NumFocus是一个目标实现更加用户友好,更加高性能的科学计算的开源社区.下面有很多有名的项目如numpy,Julia等等.</p>
</section>
    </div>
  </div>


  <script src="../lib/js/head.min.js"></script>
  <script src="../js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: '../lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../plugin/zoom-js/zoom.js', async: true },
          { src: '../plugin/notes/notes.js', async: true }
        ]
      });

    </script>
  </body>
</html>
